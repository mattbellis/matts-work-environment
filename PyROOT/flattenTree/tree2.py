import ROOT, math, array
from ROOT import AddressOf

# This example illustrates how to make a Tree from variables or arrays
# in a C struct. Use of C structs is strongly discouraged and one should
# use classes instead. However support for C structs is important for 
# legacy applications written in C or Fortran.
#    see tree2a.C for the same example using a class instead of a C-struct.
#
# In this example, we are mapping a C struct to one of the Geant3
# common blocks /gctrak/. In the real life, this common will be filled
# by Geant3 at each step and only the Tree Fill function should be called.
# The example emulates the Geant3 step routines.
#
# to run the example, do:
# .x tree2.C   to execute with the CINT interpreter
# .x tree2.C++ to execute with native compiler
#
#  Author: Rene Brun

#const Int_t MAXMEC = 30;
ROOT.MAXMEC = 30
#      PARAMETER (MAXMEC=30) 
#      COMMON/GCTRAK/VECT(7),GETOT,GEKIN,VOUT(7),NMEC,LMEC(MAXMEC) 
#     + ,NAMEC(MAXMEC),NSTEP ,PID,DESTEP,DESTEL,SAFETY,SLENG 
#     + ,STEP  ,SNEXT ,SFIELD,TOFG  ,GEKRAT,UPWGHT
ROOT.gROOT.ProcessLine(
"typedef struct {\
  Float_t  vect[7];\
  Float_t  getot;\
  Float_t  gekin;\
  Float_t  vout[7];\
  Int_t    nmec;\
  Int_t    lmec[MAXMEC];\
  Int_t    namec[MAXMEC];\
  Int_t    nstep;\
  Int_t    pid;\
  Float_t  destep;\
  Float_t  destel;\
  Float_t  safety;\
  Float_t  sleng;\
  Float_t  step;\
  Float_t  snext;\
  Float_t  sfield;\
  Float_t  tofg;\
  Float_t  gekrat;\
  Float_t  upwght;\
} Gctrak_t;" )


def helixStep( step, vect, vout ): #Float_t step, Float_t *vect, Float_t *vout)
 # extrapolate track in constant field
   field = 20           # magnetic field in kilogauss
   (kX,kY,kZ,kPX,kPY,kPZ,kPP) = range(7)
   vout[kPP] = vect[kPP]
   h4    = field*2.99792e-4
   rho   = -h4/vect[kPP];
   tet   = rho*step;
   tsint = tet*tet/6;
   sintt = 1 - tsint
   sint  = tet*sintt
   cos1t = tet/2
   f1 = step*sintt
   f2 = step*cos1t
   f3 = step*tsint*vect[kPZ]
   f4 = -tet*cos1t
   f5 = sint
   f6 = tet*cos1t*vect[kPZ]
   vout[kX]   = vect[kX]  + (f1*vect[kPX] - f2*vect[kPY])
   vout[kY]   = vect[kY]  + (f1*vect[kPY] + f2*vect[kPX])
   vout[kZ]   = vect[kZ]  + (f1*vect[kPZ] + f3)
   vout[kPX]  = vect[kPX] + (f4*vect[kPX] - f5*vect[kPY])
   vout[kPY]  = vect[kPY] + (f4*vect[kPY] + f5*vect[kPX])
   vout[kPZ]  = vect[kPZ] + (f4*vect[kPZ] + f6)


def tree2w():
 # create a Tree file tree2.root
   
 # create the file, the Tree and a few branches with 
 # a subset of gctrak
   gstep = ROOT.Gctrak_t()

   f = ROOT.TFile("tree2.root","recreate")
   t2 = ROOT.TTree("t2","a Tree with data from a fake Geant3")

   t2.Branch("vect",gstep.vect,"vect[7]/F")
   t2.Branch("getot",AddressOf(gstep,'getot'),"getot/F")
   t2.Branch("gekin",AddressOf(gstep,'gekin'),"gekin/F")
   t2.Branch("nmec",AddressOf(gstep,'nmec'),"nmec/I")
   t2.Branch("lmec",gstep.lmec,"lmec[nmec]/I")
   t2.Branch("destep",AddressOf(gstep,'destep'),"destep/F")
   t2.Branch("pid",AddressOf(gstep,'pid'),"pid/I")
   
 # Initialize particle parameters at first point
   px = py = pz = p = charge = 0
   vout = 7*[0.]
   mass  = 0.137
   newParticle = True
   gstep.step    = 0.1
   gstep.destep  = 0
   gstep.nmec    = 0
   gstep.pid     = 0
 
 # transport particles 
   for i in xrange(10000):
    # generate a new particle if necessary
      if newParticle:
         px = ROOT.gRandom.Gaus(0,.02)
         py = ROOT.gRandom.Gaus(0,.02)
         pz = ROOT.gRandom.Gaus(0,.02)
         p  = math.sqrt(px*px+py*py+pz*pz)
         charge = 1
         if ROOT.gRandom.Rndm() < 0.5: charge = -1
         gstep.pid     = gstep.pid + 1
         gstep.vect = array.array( 'f', [0., 0., 0., px/p, py/p, pz/p, p*charge] )
         gstep.getot   = math.sqrt(p*p + mass*mass)
         gstep.gekin   = gstep.getot - mass
         newParticle = False
      
    # fill the Tree with current step parameters
      t2.Fill()
      
    # transport particle in magnetic field
      helixStep( gstep.step, gstep.vect, vout )  # make one step
      
    # apply energy loss
      gstep.destep = gstep.step*ROOT.gRandom.Gaus(0.0002,0.00001)
      gstep.gekin  = gstep.gekin - gstep.destep
      gstep.getot   = gstep.gekin + mass
      vout[6] = charge*math.sqrt(gstep.getot*gstep.getot - mass*mass)
      gstep.vect = array.array( 'f', vout )
      gstep.nmec    = int(5*ROOT.gRandom.Rndm())
      if gstep.nmec:
         gstep.lmec = array.array( 'i', range(gstep.nmec) )
      if gstep.gekin < 0.001:        newParticle = True
      if abs(gstep.vect[2]) > 30:    newParticle = True
  
 # save the Tree header. The file will be automatically closed
 # when going out of the function scope
   t2.Write()
   f.Close()

def tree2r():
 # read the Tree generated by tree2w and fill one histogram
 # we are only interested by the destep branch.
     
 # note that we use "new" to create the TFile and TTree objects !
 # because we want to keep these objects alive when we leave 
 # this function.
   global f, hdestep, c1, t2      # keep alive for display
   f = ROOT.TFile("tree2.root")
   t2 = f.Get("t2")
   b_destep = t2.GetBranch("destep")
   
 # create one histogram
   hdestep = ROOT.TH1F("hdestep","destep in Mev",100,1e-5,3e-5)
   
 # read only the destep branch for all entries
   for event in t2:
      hdestep.Fill(event.destep)
  
 # we do not close the file. 
 # We want to keep the generated histograms
 # We fill a 3-d scatter plot with the particle step coordinates
   c1 = ROOT.TCanvas("c1","c1",600,800)
   c1.SetFillColor(42)
   c1.Divide(1,2)
   c1.cd(1)
   hdestep.SetFillColor(45)
   hdestep.Fit("gaus")
   hdestep.Draw(); c1.Update()
   c1.cd(2)
   ROOT.gPad.SetFillColor(37)
   t2.SetMarkerColor(ROOT.kRed)
   t2.Draw("vect[0]:vect[1]:vect[2]")
   if ROOT.gROOT.IsBatch(): return

   c1.Draw()
   
 # invoke the x3d viewer
   ROOT.gPad.GetViewer3D("x3d")


if __name__ == '__main__':
   tree2w()
   tree2r()
   c1.Update()
